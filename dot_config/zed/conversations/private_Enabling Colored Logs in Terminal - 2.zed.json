{"id":"b191b47f-4e79-46b8-a9e4-b82b055071db","zed":"context","version":"0.4.0","text":"\n\n\nhow to enable colored logs ?\nEnabling colored logs can significantly improve readability and make it easier to debug or monitor your application. The approach to enabling colored logs depends on the programming language and logging framework you are using. Here are examples for a few common languages:\n\n### Python\n\nIf you're using Python, the `logging` module doesn't support colored logs natively, but you can achieve this using third-party packages like `colorlog`.\n\n1. **Install `colorlog`:**\n\n   ```bash\n   pip install colorlog\n   ```\n\n2. **Configure logging with `colorlog`:**\n\n   ```python\n   import logging\n   from colorlog import ColoredFormatter\n\n   # Create a logger object\n   logger = logging.getLogger('my_logger')\n   logger.setLevel(logging.DEBUG)\n\n   # Create a handler\n   handler = logging.StreamHandler()\n\n   # Set the colored formatter\n   formatter = ColoredFormatter(\n       \"%(log_color)s%(levelname)s: %(message)s\",\n       log_colors={\n           'DEBUG': 'white',\n           'INFO': 'green',\n           'WARNING': 'yellow',\n           'ERROR': 'red',\n           'CRITICAL': 'bold_red',\n       }\n   )\n   handler.setFormatter(formatter)\n\n   # Add the handler to the logger\n   logger.addHandler(handler)\n\n   # Log some messages\n   logger.debug(\"This is a debug message\")\n   logger.info(\"This is an info message\")\n   logger.warning(\"This is a warning message\")\n   logger.error(\"This is an error message\")\n   logger.critical(\"This is a critical message\")\n   ```\n\n### JavaScript (Node.js)\n\nFor Node.js, you can use packages like `winston` with `winston-format` or `chalk`.\n\n1. **Using `winston` and `winston-transport`:**\n\n   ```bash\n   npm install winston chalk\n   ```\n\n2. **Configure `winston` with `chalk` for colored output:**\n\n   ```javascript\n   const winston = require('winston');\n   const chalk = require('chalk');\n\n   const customFormat = winston.format.printf(({ level, message }) => {\n     let colorFn;\n     switch (level) {\n       case 'info':\n         colorFn = chalk.green;\n         break;\n       case 'warn':\n         colorFn = chalk.yellow;\n         break;\n       case 'error':\n         colorFn = chalk.red;\n         break;\n       default:\n         colorFn = chalk.white;\n     }\n     return colorFn(`${level}: ${message}`);\n   });\n\n   const logger = winston.createLogger({\n     level: 'info',\n     format: winston.format.combine(\n       winston.format.colorize(),\n       customFormat\n     ),\n     transports: [new winston.transports.Console()],\n   });\n\n   logger.info('This is an info message');\n   logger.warn('This is a warning message');\n   logger.error('This is an error message');\n   ```\n\n### Bash\n\nFor enabling colored logs in a Bash script, use ANSI escape codes directly:\n\n```bash\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[0;33m'\nNC='\\033[0m' # No Color\n\necho -e \"${GREEN}This is a green message${NC}\"\necho -e \"${YELLOW}This is a yellow message${NC}\"\necho -e \"${RED}This is a red message${NC}\"\n```\n\n### Other Languages\n\nFor other languages, you can typically find third-party libraries dedicated to logging and many of them offer support for colored logs. The key idea is to format your logs using escape sequences or use a library that manages these formats for you.\n\nIn any case, ensure that your terminal supports colored output, as some environments might not render colors correctly.\n```rs openobserve/src/common/utils/zo_logger.rs\n// Copyright 2024 OpenObserve Inc.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::sync::Arc;\n\nuse cloudevents::{Event, EventBuilder, EventBuilderV10};\nuse config::{get_config, ider, utils::json};\nuse log::{Metadata, Record};\nuse once_cell::sync::Lazy;\nuse reqwest::Client;\nuse tokio::sync::{broadcast, RwLock};\n\npub static EVENT_SENDER: Lazy<broadcast::Sender<Event>> = Lazy::new(|| {\n    let (tx, _) = broadcast::channel(1024);\n    tx\n});\n\npub static LOGS: Lazy<Arc<RwLock<Vec<Event>>>> = Lazy::new(|| Arc::new(RwLock::new(vec![])));\n\npub struct ZoLogger {\n    pub sender: broadcast::Sender<Event>,\n}\n\nimpl log::Log for ZoLogger {\n    fn enabled(&self, _metadata: &Metadata) -> bool {\n        get_config().log.events_enabled\n    }\n\n    fn log(self: &ZoLogger, record: &Record) {\n        if self.enabled(record.metadata()) {\n            let ts = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Micros, true);\n            let level = record.level();\n            let file = record.file().unwrap_or(\"\").replace('/', \":\");\n            let line = record.line().unwrap_or(0);\n            let message = record.args();\n            println!(\"[{ts} {level} {file}]:{line} {message}\");\n\n            let payload = json::json!({\n                \"ts\": ts,\n                \"level\": level.to_string(),\n                \"file\": file,\n                \"line\": line,\n                \"message\": message,\n\n            });\n\n            let event = EventBuilderV10::new()\n                .id(ider::generate())\n                .ty(\"debug_log\")\n                .source(get_config().common.instance_name.clone())\n                .data(\"application/json\", payload)\n                .build()\n                .unwrap();\n\n            let _ = self.sender.send(event);\n        }\n    }\n    fn flush(&self) {}\n}\n\npub async fn send_logs() {\n    let mut event_receiver_rx = EVENT_SENDER.subscribe();\n    let cl = Arc::new(Client::builder().build().unwrap());\n\n    while let Ok(val) = event_receiver_rx.recv().await {\n        let mut logs = LOGS.write().await;\n        logs.push(val);\n\n        let cfg = get_config();\n        if logs.len() >= cfg.log.events_batch_size {\n            let old_logs = std::mem::take(&mut *logs);\n            let url = url::Url::parse(&cfg.log.events_url).unwrap();\n            let auth = format!(\"Basic {}\", &cfg.log.events_auth);\n            let cl = Arc::clone(&cl);\n            tokio::task::spawn(async move {\n                let _ = cl\n                    .post(url)\n                    .header(\"Content-Type\", \"application/cloudevents+json\")\n                    .header(reqwest::header::AUTHORIZATION, auth)\n                    .json(&old_logs)\n                    .send()\n                    .await;\n            });\n        }\n    }\n}\n```\n\nin this\nIn the Rust code you've provided, a custom logger `ZoLogger` is implemented, but it currently lacks support for colored logs. To add colored logs to this implementation, you can make use of the `colored` crate, which allows you to easily add ANSI colors to terminal output. Hereâ€™s how you can modify the `ZoLogger` to include colored output depending on the log level:\n\n1. **Add the `colored` crate to your `Cargo.toml`:**\n\n   ```toml\n   [dependencies]\n   colored = \"2.0\"\n   ```\n\n2. **Modify the `ZoLogger` implementation to use the `colored` crate:**\n\n   First, import the necessary traits from the `colored` crate at the top of your file:\n\n   ```rust\n   use colored::*;\n   ```\n\n3. **Add color to your logger output:**\n\n   Modify the `println!` statement in the `log` method to include color formatting based on the log level:\n\n   ```rust\n   fn log(self: &ZoLogger, record: &Record) {\n       if self.enabled(record.metadata()) {\n           let ts = chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Micros, true);\n           let level = record.level();\n           let colored_level = match level {\n               log::Level::Error => \"ERROR\".red(),\n               log::Level::Warn => \"WARN\".yellow(),\n               log::Level::Info => \"INFO\".green(),\n               log::Level::Debug => \"DEBUG\".cyan(),\n               log::Level::Trace => \"TRACE\".normal(), // Or any other color you prefer\n           };\n           let file = record.file().unwrap_or(\"\").replace('/', \":\");\n           let line = record.line().unwrap_or(0);\n           let message = record.args();\n           println!(\"[{ts} {colored_level} {file}]:{line} {message}\");\n\n           let payload = json::json!({\n               \"ts\": ts,\n               \"level\": level.to_string(),\n               \"file\": file,\n               \"line\": line,\n               \"message\": message,\n           });\n\n           let event = EventBuilderV10::new()\n               .id(ider::generate())\n               .ty(\"debug_log\")\n               .source(get_config().common.instance_name.clone())\n               .data(\"application/json\", payload)\n               .build()\n               .unwrap();\n\n           let _ = self.sender.send(event);\n       }\n   }\n   ```\n\nThis code snippet modifies the `log` function to use the `colored` crate to add color formatting to log levels. Different colors are assigned to different log levels, making it easier to distinguish them in the terminal.\n\nRemember that this code assumes the user's terminal supports ANSI colors. If the logs are being directed to a file or another destination that does not support ANSI escape codes, this colorization will not work as expected.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":57}}},{"id":{"replica_id":0,"value":14},"start":32,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":58}}},{"id":{"replica_id":0,"value":15},"start":3339,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":59}}},{"id":{"replica_id":0,"value":51},"start":6772,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":60}}},{"id":{"replica_id":0,"value":52},"start":9429,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":61}}}],"summary":"Enabling Colored Logs in Terminal","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3339,"end":6763},"icon":"File","label":"openobserve/src/common/utils/zo_logger.rs","metadata":{"path":"openobserve/src/common/utils/zo_logger.rs"}}],"thought_process_output_sections":[]}