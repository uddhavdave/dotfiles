{"id":"58b17c91-a43d-451b-99d0-95f31a5b1fd0","zed":"context","version":"0.4.0","text":"\n\n\n```rs openobserve/src/config/src/meta/puffin/reader.rs\n// Copyright 2024 Zinc Labs Inc.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::io::{Read, Seek, SeekFrom};\n\nuse anyhow::{anyhow, ensure, Result};\nuse futures::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt};\n\nuse super::{\n    BlobMetadata, PuffinFooterFlags, PuffinMeta, FLAGS_SIZE, FOOTER_PAYLOAD_SIZE_SIZE, MAGIC,\n    MAGIC_SIZE,\n};\nuse crate::meta::puffin::{CompressionCodec, MIN_FILE_SIZE};\n\n#[derive(Debug)]\npub struct PuffinBytesReader<R> {\n    source: R,\n    metadata: Option<PuffinMeta>,\n}\n\nimpl<R> PuffinBytesReader<R> {\n    pub fn new(source: R) -> Self {\n        Self {\n            source,\n            metadata: None,\n        }\n    }\n}\n\nimpl<R: Read + Seek> PuffinBytesReader<R> {\n    pub fn read_blob_bytes(&mut self, blob_metadata: &BlobMetadata) -> Result<Vec<u8>> {\n        // Seek to the start of the blob\n        self.source\n            .seek(SeekFrom::Start(blob_metadata.offset as _))?;\n\n        let mut compressed = vec![0u8; blob_metadata.length as usize];\n        self.source.read_exact(&mut compressed)?;\n\n        let decompressed = match blob_metadata.compression_codec {\n            Some(CompressionCodec::Lz4) => {\n                unimplemented!()\n            }\n            Some(CompressionCodec::Zstd) => {\n                let mut decompressed = Vec::new();\n                let mut decoder = zstd::Decoder::new(&compressed[..])?;\n                decoder.read_to_end(&mut decompressed)?;\n                decompressed\n            }\n            None => compressed,\n        };\n        // decompress bytes since OpenObserve InvertedIndex compresses index data by default\n        // This check should be outside the puffin reader logic\n        // ensure!(\n        //     blob_metadata.compression_codec == Some(CompressionCodec::Zstd),\n        //     anyhow!(\"Unexpected CompressionCodex found in BlobMetadata\")\n        // );\n\n        Ok(decompressed)\n    }\n}\n\nimpl<R: AsyncRead + AsyncSeek + Unpin + Send> PuffinBytesReader<R> {\n    pub async fn read_blob_bytes(&mut self, blob_metadata: &BlobMetadata) -> Result<Vec<u8>> {\n        // Seek to the start of the blob\n        self.source\n            .seek(SeekFrom::Start(blob_metadata.offset as _))\n            .await?;\n\n        let mut compressed = vec![0u8; blob_metadata.length as usize];\n        self.source.read_exact(&mut compressed).await?;\n\n        let decompressed = match blob_metadata.compression_codec {\n            Some(CompressionCodec::Lz4) => {\n                unimplemented!()\n            }\n            Some(CompressionCodec::Zstd) => {\n                let mut decompressed = Vec::new();\n                let mut decoder = zstd::Decoder::new(&compressed[..])?;\n                decoder.read_to_end(&mut decompressed)?;\n                decompressed\n            }\n            None => compressed,\n        };\n        // decompress bytes since OpenObserve InvertedIndex compresses index data by default\n        // This check should be outside the puffin reader logic\n        // ensure!(\n        //     blob_metadata.compression_codec == Some(CompressionCodec::Zstd),\n        //     anyhow!(\"Unexpected CompressionCodex found in BlobMetadata\")\n        // );\n\n        Ok(decompressed)\n    }\n\n    pub async fn get_metadata(&mut self) -> Result<PuffinMeta> {\n        if let Some(meta) = &self.metadata {\n            return Ok(meta.clone());\n        }\n\n        // check MAGIC\n        let mut magic = [0u8; MAGIC_SIZE as usize];\n        self.source.read_exact(&mut magic).await?;\n        ensure!(magic == MAGIC, anyhow!(\"Header MAGIC mismatch\"));\n\n        let end_offset = self.source.seek(SeekFrom::End(0)).await?;\n        ensure!(\n            end_offset >= MIN_FILE_SIZE,\n            anyhow!(\n                \"Unexpected bytes size: minimal size {} vs actual size {}\",\n                MIN_FILE_SIZE,\n                end_offset\n            )\n        );\n\n        let puffin_meta = PuffinFooterBytesReader::new(&mut self.source, end_offset)\n            .parse()\n            .await\n            .unwrap();\n        self.metadata = Some(puffin_meta.clone());\n\n        Ok(puffin_meta)\n    }\n}\n\n/// Footer layout: HeadMagic Payload PayloadSize Flags FootMagic\n///                [4]       [?]     [4]         [4]   [4]\nstruct PuffinFooterBytesReader<R> {\n    source: R,\n    file_size: u64,\n    flags: PuffinFooterFlags,\n    payload_size: u64,\n    metadata: Option<PuffinMeta>,\n}\n\nimpl<R> PuffinFooterBytesReader<R> {\n    fn new(source: R, file_size: u64) -> Self {\n        Self {\n            source,\n            file_size,\n            flags: PuffinFooterFlags::empty(),\n            payload_size: 0,\n            metadata: None,\n        }\n    }\n}\n\nimpl<R: AsyncRead + AsyncSeek + Unpin + Send> PuffinFooterBytesReader<R> {\n    async fn parse(mut self) -> Result<PuffinMeta> {\n        // read the footer magic and\n        self.source\n            .seek(SeekFrom::Start(self.footer_magic_offset()))\n            .await?;\n        let mut magic = [0u8; MAGIC_SIZE as usize];\n        self.source.read_exact(&mut magic).await?;\n        ensure!(magic == MAGIC, anyhow!(\"Footer MAGIC mismatch\"));\n\n        self.source\n            .seek(SeekFrom::Start(self.flags_offset()))\n            .await?;\n        let mut flags = [0u8; FLAGS_SIZE as usize];\n        self.source.read_exact(&mut flags).await?;\n        self.flags = PuffinFooterFlags::from_bits(u32::from_le_bytes(flags))\n            .ok_or_else(|| anyhow!(\"Error parsing Puffin flags from bytes\"))?;\n\n        self.source\n            .seek(SeekFrom::Start(self.payload_size_offset()))\n            .await?;\n        let mut payload_size = [0u8; FOOTER_PAYLOAD_SIZE_SIZE as usize];\n        self.source.read_exact(&mut payload_size).await?;\n        self.payload_size = i32::from_le_bytes(payload_size) as u64;\n\n        self.source\n            .seek(SeekFrom::Start(self.payload_offset()))\n            .await?;\n        let mut payload: Vec<u8> = Vec::with_capacity(self.payload_size as usize);\n        payload.resize(self.payload_size as usize, 0);\n        self.source.read(&mut payload).await?;\n        self.metadata = Some(self.parse_payload(&payload)?);\n        self.validate_payload()?;\n\n        self.source\n            .seek(SeekFrom::Start(self.head_magic_offset()))\n            .await?;\n        self.source.read_exact(&mut magic).await?;\n        ensure!(magic == MAGIC, anyhow!(\"Footer MAGIC mismatch\"));\n\n        Ok(self.metadata.unwrap())\n    }\n\n    fn parse_payload(&self, bytes: &[u8]) -> Result<PuffinMeta> {\n        if self.flags.contains(PuffinFooterFlags::COMPRESSED_ZSTD) {\n            let decoder = zstd::Decoder::new(bytes)?;\n            serde_json::from_reader(decoder)\n                .map_err(|e| anyhow!(\"Error decompress footer payload {}\", e.to_string()))\n        } else {\n            serde_json::from_slice(bytes)\n                .map_err(|e| anyhow!(\"Error serializing footer {}\", e.to_string()))\n        }\n    }\n\n    fn validate_payload(&self) -> Result<()> {\n        let puffin_metadata = self.metadata.as_ref().expect(\"metadata is not set\");\n\n        let mut offset = MAGIC_SIZE;\n        for blob in &puffin_metadata.blob_metadata {\n            ensure!(\n                blob.offset as u64 == offset,\n                anyhow!(\"Blob payload offset mismatch\")\n            );\n            offset += blob.length as u64;\n        }\n\n        let payload_ends_at = puffin_metadata\n            .blob_metadata\n            .last()\n            .map_or(MAGIC_SIZE, |blob| (blob.offset + blob.length) as u64);\n\n        ensure!(\n            payload_ends_at == self.head_magic_offset(),\n            anyhow!(\"Payload chunk offset mismatch\")\n        );\n        Ok(())\n    }\n\n    fn footer_magic_offset(&self) -> u64 {\n        self.file_size - MAGIC_SIZE\n    }\n\n    fn flags_offset(&self) -> u64 {\n        self.footer_magic_offset() - FLAGS_SIZE\n    }\n\n    fn payload_size_offset(&self) -> u64 {\n        self.flags_offset() - FOOTER_PAYLOAD_SIZE_SIZE\n    }\n\n    fn payload_offset(&self) -> u64 {\n        self.payload_size_offset() - self.payload_size\n    }\n\n    fn head_magic_offset(&self) -> u64 {\n        self.payload_offset() - MAGIC_SIZE\n    }\n}\n```\n```rust\n\nimpl<R: Read + Seek> PuffinBytesReader<R> {\n    pub fn read_blob_bytes(&mut self, blob_metadata: &BlobMetadata) -> Result<Vec<u8>> {\n// error: duplicate definitions with name `read_blob_bytes`\n//        duplicate definitions for `read_blob_bytes`\n        // Seek to the start of the blob\n        self.source\n```\n\nwhy can i not introduce new blocking method to puffinbytesreader with the same name, I have different Trait Bounds still?\nIn Rust, you cannot have two methods with the same name in a single implementation block, even if they have different trait bounds. This is because Rust doesn't support method overloading based on type parameters or trait bounds as some other languages do. When you try to add a method with the same name in a different implementation block, the compiler will still see it as a duplicate definition, because it considers methods unique by their name and the type they are defined in.\n\nIn your case, you have a single `PuffinBytesReader<R>` struct with two different implementations of the `read_blob_bytes` method: one is synchronous, and the other is asynchronous. Since both methods have the same name and belong to the same struct, Rust sees this as a conflict.\n\nTo resolve this, you have a few options:\n\n1. **Rename one of the methods:** This is the simplest approach. You could give each method a distinct name based on their behavior or their trait bounds. For example, `read_blob_bytes_sync` for the synchronous version and `read_blob_bytes_async` for the asynchronous version.\n\n2. **Use separate wrapper structs:** If you want to keep the method names the same, you could create separate structs or wrapper types for synchronous and asynchronous operations. Each struct would have its own implementation of `read_blob_bytes`, which would then compile without issue.\n\n3. **Use a trait for each version:** Define traits for the synchronous and asynchronous operations with methods named `read_blob_bytes`. Then provide separate implementations for these traits for `PuffinBytesReader<R>`.\n\nHere's an example using the rename approach:\n\n```rust\nimpl<R: Read + Seek> PuffinBytesReader<R> {\n    pub fn read_blob_bytes_sync(&mut self, blob_metadata: &BlobMetadata) -> Result<Vec<u8>> {\n        // Seek to the start of the blob\n        self.source\n            .seek(SeekFrom::Start(blob_metadata.offset as _))?;\n\n        let mut compressed = vec![0u8; blob_metadata.length as usize];\n        self.source.read_exact(&mut compressed)?;\n\n        // Handle decompression...\n    }\n}\n\nimpl<R: AsyncRead + AsyncSeek + Unpin + Send> PuffinBytesReader<R> {\n    pub async fn read_blob_bytes_async(&mut self, blob_metadata: &BlobMetadata) -> Result<Vec<u8>> {\n        // Seek to the start of the blob\n        self.source\n            .seek(SeekFrom::Start(blob_metadata.offset as _))\n            .await?;\n\n        let mut compressed = vec![0u8; blob_metadata.length as usize];\n        self.source.read_exact(&mut compressed).await?;\n\n        // Handle decompression...\n    }\n}\n```\n\nBy renaming the methods, you avoid the name conflict while still providing both synchronous and asynchronous versions of the function.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":35}}},{"id":{"replica_id":0,"value":29},"start":9202,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":36}}},{"id":{"replica_id":0,"value":30},"start":11908,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":37}}}],"summary":"Implementing blocking and asynchronous methods for PuffinBytesReader in Rust","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":9079},"icon":"File","label":"openobserve/src/config/src/meta/puffin/reader.rs","metadata":{"path":"openobserve/src/config/src/meta/puffin/reader.rs"}},{"range":{"start":8758,"end":9078},"icon":"XCircle","label":"duplicate definitions with name `read_blob_bytes`\nduplicate definitions for `read_blob_bytes`","metadata":null}]}