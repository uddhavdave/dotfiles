{"id":"e3e0619b-87a9-43e6-843f-804293ab1fcf","zed":"context","version":"0.4.0","text":"\n\n\n\n```rs openobserve/src/service/search/grpc/storage.rs:708-798\n// Excerpt from: async fn search_tantivy_index\nasync fn search_tantivy_index(\n    trace_id: &str,\n    parquet_file_name: &str,\n    fts_terms: Arc<Vec<String>>,\n    index_terms: Arc<Vec<(String, Vec<String>)>>,\n) -> anyhow::Result<(String, Option<BitVec>)> {\n    let cfg = get_config();\n    let Some(tantivy_index_file_name) =\n        convert_parquet_idx_file_name_to_tantivy_file(parquet_file_name)\n    else {\n        return Err(anyhow::anyhow!(\n            \"[trace_id {trace_id}] search->storage: Unable to find tantivy index files for parquet file {}\",\n            parquet_file_name\n        ));\n    };\n\n    let fetch_start = std::time::Instant::now();\n    let index_file_bytes = fetch_file(trace_id, &tantivy_index_file_name).await?;\n    let elapsed_fetch = fetch_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: fetch_file took {} s, {} ms\",\n        trace_id,\n        elapsed_fetch.as_secs(),\n        elapsed_fetch.as_millis(),\n    );\n\n    let tantivy_searcher_start = std::time::Instant::now();\n    let puffin_dir = PuffinDirReader::from_bytes(Cursor::new(index_file_bytes)).await?;\n    let tantivy_index = tantivy::Index::open(puffin_dir)?;\n    let tantivy_schema = tantivy_index.schema();\n    let tantivy_reader = tantivy_index.reader().unwrap();\n    let tantivy_searcher = tantivy_reader.searcher();\n    let elapsed_tantivy_searcher = tantivy_searcher_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: tantivy_searcher took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n\n    let mut matched_docs = HashSet::new();\n\n    let mut max_doc_id = 0u32;\n    if !fts_terms.is_empty() {\n        let fts_field = tantivy_schema.get_field(\"_all\").unwrap();\n        let query_parser = QueryParser::for_index(&tantivy_index, vec![fts_field]);\n        let tantivy_searcher_clone = tantivy_searcher.clone();\n        if let Ok((docs, max_row)) = tokio::task::spawn_blocking(move || {\n            search_tantivy_index_with_field(\n                query_parser,\n                fts_field,\n                tantivy_searcher_clone,\n                &*fts_terms,\n            )\n        })\n        .await?\n        {\n            matched_docs.extend(docs);\n            max_doc_id = max_row;\n        } else {\n            return Err(anyhow::anyhow!(\n                \"[trace_id {}] search->storage: search_full_text_index failed\",\n                trace_id\n            ));\n        };\n    }\n    log::info!(\n        \"[trace_id {}] search->storage: fts_search took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n    for (field_name, terms) in index_terms.iter() {\n        let field = tantivy_schema.get_field(&field_name).unwrap();\n        let query_parser = QueryParser::for_index(&tantivy_index, vec![field]);\n        let tantivy_searcher_clone = tantivy_searcher.clone();\n\n        if let Ok((docs, max_row)) = tokio::task::spawn_blocking(move || {\n            search_tantivy_index_with_field(query_parser, field, tantivy_searcher_clone, &terms)\n        })\n        .await?\n        {\n            matched_docs.extend(docs);\n            max_doc_id = max_row;\n        } else {\n            return Err(anyhow::anyhow!(\n                \"[trace_id {}] search->storage: search_full_text_index failed\",\n                trace_id\n            ));\n        };\n    }\n```\nIm getting a does not live long enough error here, please help fix\nThe error you're encountering occurs when borrowing rules in Rust are violated, typically because of lifetime issues. Let's examine the code to identify where the problem might arise and suggest a fix. \n\nThe problem with \"`does not live long enough`\" often arises when a value or reference is used outside of its expected scope. Due to the complex lifetime relationships in Rust, certain actions can inadvertently violate these scoping rules. In the context of your code, this error might be causing by attempting to use borrowed values (`fts_terms`, `index_terms`) across async boundaries improperly.\n\nHere's an adjusted version of your code, emphasizing the lifetime management of variables across async operations:\n\n```rust\nuse std::collections::HashSet;\nuse std::io::Cursor;\nuse std::sync::Arc;\nuse tantivy::query::QueryParser;\nuse tantivy::schema::Schema;\nuse tantivy::{schema::Field, Index, IndexReader, Searcher};\nuse tokio::task;\n\nasync fn search_tantivy_index(\n    trace_id: &str,\n    parquet_file_name: &str,\n    fts_terms: Arc<Vec<String>>,\n    index_terms: Arc<Vec<(String, Vec<String>)>>,\n) -> anyhow::Result<(String, Option<BitVec>)> {\n    let cfg = get_config();\n\n    let tantivy_index_file_name = match convert_parquet_idx_file_name_to_tantivy_file(parquet_file_name) {\n        Some(name) => name,\n        None => {\n            return Err(anyhow::anyhow!(\n                \"[trace_id {trace_id}] search->storage: Unable to find tantivy index files for parquet file {}\",\n                parquet_file_name\n            ));\n        }\n    };\n\n    let fetch_start = std::time::Instant::now();\n    let index_file_bytes = fetch_file(trace_id, &tantivy_index_file_name).await?;\n    let elapsed_fetch = fetch_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: fetch_file took {} s, {} ms\",\n        trace_id,\n        elapsed_fetch.as_secs(),\n        elapsed_fetch.as_millis(),\n    );\n\n    let tantivy_searcher_start = std::time::Instant::now();\n    let puffin_dir = PuffinDirReader::from_bytes(Cursor::new(index_file_bytes)).await?;\n    let tantivy_index = tantivy::Index::open(puffin_dir)?;\n    let tantivy_schema = tantivy_index.schema();\n    let tantivy_reader = tantivy_index.reader().unwrap();\n    let tantivy_searcher = tantivy_reader.searcher();\n    let elapsed_tantivy_searcher = tantivy_searcher_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: tantivy_searcher took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n\n    let mut matched_docs = HashSet::new();\n    let mut max_doc_id = 0u32;\n    \n    if !fts_terms.is_empty() {\n        let fts_field = tantivy_schema.get_field(\"_all\").unwrap();\n        let query_parser = QueryParser::for_index(&tantivy_index, vec![fts_field]);\n        \n        // Move the terms and searcher into the blocking task\n        let fts_terms = Arc::clone(&fts_terms);\n        let tantivy_searcher_clone = tantivy_searcher.clone();\n        let result = task::spawn_blocking(move || {\n            search_tantivy_index_with_field(query_parser, fts_field, tantivy_searcher_clone, &*fts_terms)\n        })\n        .await?;\n        \n        if let Ok((docs, max_row)) = result {\n            matched_docs.extend(docs);\n            max_doc_id = max_row;\n        } else {\n            return Err(anyhow::anyhow!(\n                \"[trace_id {}] search->storage: search_full_text_index failed\",\n                trace_id\n            ));\n        }\n    }\n    log::info!(\n        \"[trace_id {}] search->storage: fts_search took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n\n    for (field_name, terms) in &**index_terms {\n        let field = tantivy_schema.get_field(&field_name).unwrap();\n        let query_parser = QueryParser::for_index(&tantivy_index, vec![field]);\n        \n        // Clone the terms for use in the blocking task\n        let terms = terms.clone();\n        let tantivy_searcher_clone = tantivy_searcher.clone();\n        let result = task::spawn_blocking(move || {\n            search_tantivy_index_with_field(query_parser, field, tantivy_searcher_clone, &terms)\n        })\n        .await?;\n        \n        if let Ok((docs, max_row)) = result {\n            matched_docs.extend(docs);\n            max_doc_id = max_row;\n        } else {\n            return Err(anyhow::anyhow!(\n                \"[trace_id {}] search->storage: search_full_text_index failed\",\n                trace_id\n            ));\n        }\n    }\n\n    // Return a placeholder result, adjust it according to your logic\n    Ok((\"Result Placeholder\".to_string(), None))\n}\n```\n\n**Key Changes**:\n1. **Cloning Arcs**: We have used `Arc::clone()` to pass cloned references to `tokio::spawn_blocking`. This ensures that the async tasks have access to the data without causing lifetime issues.\n2. **By-reference Iteration**: Used `&**index_terms` to dereference the Arc and iterate by reference, maintaining proper data access.\n\nIn this solution, we ensure the data is properly shared across boundaries, effectively addressing Rust's stringent lifetime requirements. Adjust the return logic according to your application needs.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":23}}},{"id":{"replica_id":0,"value":11},"start":3571,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":24}}},{"id":{"replica_id":0,"value":12},"start":8810,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":25}}}],"summary":"Lifetime error in async function `search_tantivy_index` in Rust code","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}