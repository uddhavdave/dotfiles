{"id":"233ed6b1-51b7-4964-bbfc-c87ab3fe42ed","zed":"context","version":"0.4.0","text":"\n\n\n```rs searcher.rs/\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::{fmt, io};\n\nuse crate::collector::Collector;\nuse crate::core::Executor;\nuse crate::index::{SegmentId, SegmentReader};\nuse crate::query::{Bm25StatisticsProvider, EnableScoring, Query};\nuse crate::schema::document::DocumentDeserialize;\nuse crate::schema::{Schema, Term};\nuse crate::space_usage::SearcherSpaceUsage;\nuse crate::store::{CacheStats, StoreReader};\nuse crate::{DocAddress, Index, Opstamp, TrackedObject};\n\n/// Identifies the searcher generation accessed by a [`Searcher`].\n///\n/// While this might seem redundant, a [`SearcherGeneration`] contains\n/// both a `generation_id` AND a list of `(SegmentId, DeleteOpstamp)`.\n///\n/// This is on purpose. This object is used by the [`Warmer`](crate::reader::Warmer) API.\n/// Having both information makes it possible to identify which\n/// artifact should be refreshed or garbage collected.\n///\n/// Depending on the use case, `Warmer`'s implementers can decide to\n/// produce artifacts per:\n/// - `generation_id` (e.g. some searcher level aggregates)\n/// - `(segment_id, delete_opstamp)` (e.g. segment level aggregates)\n/// - `segment_id` (e.g. for immutable document level information)\n/// - `(generation_id, segment_id)` (e.g. for consistent dynamic column)\n/// - ...\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct SearcherGeneration {\n    segments: BTreeMap<SegmentId, Option<Opstamp>>,\n    generation_id: u64,\n}\n\nimpl SearcherGeneration {\n    pub(crate) fn from_segment_readers(\n        segment_readers: &[SegmentReader],\n        generation_id: u64,\n    ) -> Self {\n        let mut segment_id_to_del_opstamp = BTreeMap::new();\n        for segment_reader in segment_readers {\n            segment_id_to_del_opstamp\n                .insert(segment_reader.segment_id(), segment_reader.delete_opstamp());\n        }\n        Self {\n            segments: segment_id_to_del_opstamp,\n            generation_id,\n        }\n    }\n\n    /// Returns the searcher generation id.\n    pub fn generation_id(&self) -> u64 {\n        self.generation_id\n    }\n\n    /// Return a `(SegmentId -> DeleteOpstamp)` mapping.\n    pub fn segments(&self) -> &BTreeMap<SegmentId, Option<Opstamp>> {\n        &self.segments\n    }\n}\n\n/// Holds a list of `SegmentReader`s ready for search.\n///\n/// It guarantees that the `Segment` will not be removed before\n/// the destruction of the `Searcher`.\n#[derive(Clone)]\npub struct Searcher {\n    inner: Arc<SearcherInner>,\n}\n\nimpl Searcher {\n    /// Returns the `Index` associated with the `Searcher`\n    pub fn index(&self) -> &Index {\n        &self.inner.index\n    }\n\n    /// [`SearcherGeneration`] which identifies the version of the snapshot held by this `Searcher`.\n    pub fn generation(&self) -> &SearcherGeneration {\n        self.inner.generation.as_ref()\n    }\n\n    /// Fetches a document from tantivy's store given a [`DocAddress`].\n    ///\n    /// The searcher uses the segment ordinal to route the\n    /// request to the right `Segment`.\n    pub fn doc<D: DocumentDeserialize>(&self, doc_address: DocAddress) -> crate::Result<D> {\n        let store_reader = &self.inner.store_readers[doc_address.segment_ord as usize];\n        store_reader.get(doc_address.doc_id)\n    }\n\n    /// The cache stats for the underlying store reader.\n    ///\n    /// Aggregates the sum for each segment store reader.\n    pub fn doc_store_cache_stats(&self) -> CacheStats {\n        let cache_stats: CacheStats = self\n            .inner\n            .store_readers\n            .iter()\n            .map(|reader| reader.cache_stats())\n            .sum();\n        cache_stats\n    }\n\n    /// Fetches a document in an asynchronous manner.\n    #[cfg(feature = \"quickwit\")]\n    pub async fn doc_async<D: DocumentDeserialize>(\n        &self,\n        doc_address: DocAddress,\n    ) -> crate::Result<D> {\n        let executor = self.inner.index.search_executor();\n        let store_reader = &self.inner.store_readers[doc_address.segment_ord as usize];\n        store_reader.get_async(doc_address.doc_id, executor).await\n    }\n\n    /// Access the schema associated with the index of this searcher.\n    pub fn schema(&self) -> &Schema {\n        &self.inner.schema\n    }\n\n    /// Returns the overall number of documents in the index.\n    pub fn num_docs(&self) -> u64 {\n        self.inner\n            .segment_readers\n            .iter()\n            .map(|segment_reader| u64::from(segment_reader.num_docs()))\n            .sum::<u64>()\n    }\n\n    /// Return the overall number of documents containing\n    /// the given term.\n    pub fn doc_freq(&self, term: &Term) -> crate::Result<u64> {\n        let mut total_doc_freq = 0;\n        for segment_reader in &self.inner.segment_readers {\n            let inverted_index = segment_reader.inverted_index(term.field())?;\n            let doc_freq = inverted_index.doc_freq(term)?;\n            total_doc_freq += u64::from(doc_freq);\n        }\n        Ok(total_doc_freq)\n    }\n\n    /// Return the overall number of documents containing\n    /// the given term in an asynchronous manner.\n    #[cfg(feature = \"quickwit\")]\n    pub async fn doc_freq_async(&self, term: &Term) -> crate::Result<u64> {\n        let mut total_doc_freq = 0;\n        for segment_reader in &self.inner.segment_readers {\n            let inverted_index = segment_reader.inverted_index(term.field())?;\n            let doc_freq = inverted_index.doc_freq_async(term).await?;\n            total_doc_freq += u64::from(doc_freq);\n        }\n        Ok(total_doc_freq)\n    }\n\n    /// Return the list of segment readers\n    pub fn segment_readers(&self) -> &[SegmentReader] {\n        &self.inner.segment_readers\n    }\n\n    /// Returns the segment_reader associated with the given segment_ord\n    pub fn segment_reader(&self, segment_ord: u32) -> &SegmentReader {\n        &self.inner.segment_readers[segment_ord as usize]\n    }\n\n    /// Runs a query on the segment readers wrapped by the searcher.\n    ///\n    /// Search works as follows :\n    ///\n    ///  First the weight object associated with the query is created.\n    ///\n    ///  Then, the query loops over the segments and for each segment :\n    ///  - setup the collector and informs it that the segment being processed has changed.\n    ///  - creates a SegmentCollector for collecting documents associated with the segment\n    ///  - creates a `Scorer` object associated for this segment\n    ///  - iterate through the matched documents and push them to the segment collector.\n    ///\n    ///  Finally, the Collector merges each of the child collectors into itself for result usability\n    ///  by the caller.\n    pub fn search<C: Collector>(\n        &self,\n        query: &dyn Query,\n        collector: &C,\n    ) -> crate::Result<C::Fruit> {\n        self.search_with_statistics_provider(query, collector, self)\n    }\n\n    /// Same as [`search(...)`](Searcher::search) but allows specifying\n    /// a [Bm25StatisticsProvider].\n    ///\n    /// This can be used to adjust the statistics used in computing BM25\n    /// scores.\n    pub fn search_with_statistics_provider<C: Collector>(\n        &self,\n        query: &dyn Query,\n        collector: &C,\n        statistics_provider: &dyn Bm25StatisticsProvider,\n    ) -> crate::Result<C::Fruit> {\n        let enabled_scoring = if collector.requires_scoring() {\n            EnableScoring::enabled_from_statistics_provider(statistics_provider, self)\n        } else {\n            EnableScoring::disabled_from_searcher(self)\n        };\n        let executor = self.inner.index.search_executor();\n        self.search_with_executor(query, collector, executor, enabled_scoring)\n    }\n\n    /// Same as [`search(...)`](Searcher::search) but multithreaded.\n    ///\n    /// The current implementation is rather naive :\n    /// multithreading is by splitting search into as many task\n    /// as there are segments.\n    ///\n    /// It is powerless at making search faster if your index consists in\n    /// one large segment.\n    ///\n    /// Also, keep in my multithreading a single query on several\n    /// threads will not improve your throughput. It can actually\n    /// hurt it. It will however, decrease the average response time.\n    pub fn search_with_executor<C: Collector>(\n        &self,\n        query: &dyn Query,\n        collector: &C,\n        executor: &Executor,\n        enabled_scoring: EnableScoring,\n    ) -> crate::Result<C::Fruit> {\n        let weight = query.weight(enabled_scoring)?;\n        let segment_readers = self.segment_readers();\n        let fruits = executor.map(\n            |(segment_ord, segment_reader)| {\n                collector.collect_segment(weight.as_ref(), segment_ord as u32, segment_reader)\n            },\n            segment_readers.iter().enumerate(),\n        )?;\n        collector.merge_fruits(fruits)\n    }\n\n    /// Summarize total space usage of this searcher.\n    pub fn space_usage(&self) -> io::Result<SearcherSpaceUsage> {\n        let mut space_usage = SearcherSpaceUsage::new();\n        for segment_reader in self.segment_readers() {\n            space_usage.add_segment(segment_reader.space_usage()?);\n        }\n        Ok(space_usage)\n    }\n}\n\nimpl From<Arc<SearcherInner>> for Searcher {\n    fn from(inner: Arc<SearcherInner>) -> Self {\n        Searcher { inner }\n    }\n}\n\n/// Holds a list of `SegmentReader`s ready for search.\n///\n/// It guarantees that the `Segment` will not be removed before\n/// the destruction of the `Searcher`.\npub(crate) struct SearcherInner {\n    schema: Schema,\n    index: Index,\n    segment_readers: Vec<SegmentReader>,\n    store_readers: Vec<StoreReader>,\n    generation: TrackedObject<SearcherGeneration>,\n}\n\nimpl SearcherInner {\n    /// Creates a new `Searcher`\n    pub(crate) fn new(\n        schema: Schema,\n        index: Index,\n        segment_readers: Vec<SegmentReader>,\n        generation: TrackedObject<SearcherGeneration>,\n        doc_store_cache_num_blocks: usize,\n    ) -> io::Result<SearcherInner> {\n        assert_eq!(\n            &segment_readers\n                .iter()\n                .map(|reader| (reader.segment_id(), reader.delete_opstamp()))\n                .collect::<BTreeMap<_, _>>(),\n            generation.segments(),\n            \"Set of segments referenced by this Searcher and its SearcherGeneration must match\"\n        );\n        let store_readers: Vec<StoreReader> = segment_readers\n            .iter()\n            .map(|segment_reader| segment_reader.get_store_reader(doc_store_cache_num_blocks))\n            .collect::<io::Result<Vec<_>>>()?;\n\n        Ok(SearcherInner {\n            schema,\n            index,\n            segment_readers,\n            store_readers,\n            generation,\n        })\n    }\n}\n\nimpl fmt::Debug for Searcher {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let segment_ids = self\n            .segment_readers()\n            .iter()\n            .map(SegmentReader::segment_id)\n            .collect::<Vec<_>>();\n        write!(f, \"Searcher({segment_ids:?})\")\n    }\n}\n```\nwhat is collector here and how does the Searcher::search method work?\n\nIn the provided Rust code, a `Collector` is a trait that defines how search results are collected and processed during a search operation. The `Collector` trait is used to gather and aggregate results from different segments of an index. The `Searcher::search` method utilizes this trait to perform a search query and collect the results.\n\n### Collector Trait\n\nThe `Collector` trait is not explicitly defined in the provided code snippet, but we can infer its purpose and some of its methods based on how it is used in the `Searcher` struct. Typically, a `Collector` would have methods like:\n\n- `requires_scoring()`: Determines if scoring is required for the search.\n- `collect_segment()`: Collects results from a specific segment.\n- `merge_fruits()`: Merges the results (or \"fruits\") collected from different segments.\n\n### How `Searcher::search` Method Works\n\nThe `Searcher::search` method is responsible for executing a search query across multiple segments of an index and collecting the results using a `Collector`. Here's a step-by-step breakdown of how it works:\n\n1. **Query Weight Creation**:\n   - The method first creates a weight object associated with the query. This weight object is used to score documents during the search.\n   - This is done by calling `query.weight(enabled_scoring)`.\n\n2. **Segment Iteration**:\n   - The method then iterates over the segment readers. Each segment reader represents a segment of the index.\n   - For each segment, the method sets up the collector and informs it that the segment being processed has changed.\n\n3. **Segment Collection**:\n   - For each segment, the method creates a `SegmentCollector` for collecting documents associated with that segment.\n   - It then creates a `Scorer` object for scoring documents in that segment.\n   - The method iterates through the matched documents and pushes them to the segment collector.\n\n4. **Result Merging**:\n   - After processing all segments, the method merges the results (or \"fruits\") from each segment collector into the main collector.\n   - This is done by calling `collector.merge_fruits(fruits)`.\n\n5. **Return Results**:\n   - Finally, the method returns the aggregated results collected by the collector.\n\nHere's the relevant part of the `Searcher::search` method:\n\n```rust\npub fn search<C: Collector>(\n    &self,\n    query: &dyn Query,\n    collector: &C,\n) -> crate::Result<C::Fruit> {\n    self.search_with_statistics_provider(query, collector, self)\n}\n\npub fn search_with_statistics_provider<C: Collector>(\n    &self,\n    query: &dyn Query,\n    collector: &C,\n    statistics_provider: &dyn Bm25StatisticsProvider,\n) -> crate::Result<C::Fruit> {\n    let enabled_scoring = if collector.requires_scoring() {\n        EnableScoring::enabled_from_statistics_provider(statistics_provider, self)\n    } else {\n        EnableScoring::disabled_from_searcher(self)\n    };\n    let executor = self.inner.index.search_executor();\n    self.search_with_executor(query, collector, executor, enabled_scoring)\n}\n\npub fn search_with_executor<C: Collector>(\n    &self,\n    query: &dyn Query,\n    collector: &C,\n    executor: &Executor,\n    enabled_scoring: EnableScoring,\n) -> crate::Result<C::Fruit> {\n    let weight = query.weight(enabled_scoring)?;\n    let segment_readers = self.segment_readers();\n    let fruits = executor.map(\n        |(segment_ord, segment_reader)| {\n            collector.collect_segment(weight.as_ref(), segment_ord as u32, segment_reader)\n        },\n        segment_readers.iter().enumerate(),\n    )?;\n    collector.merge_fruits(fruits)\n}\n```\n\n### Summary\n\n- **Collector**: A trait that defines how search results are collected and processed.\n- **Searcher::search**: Executes a search query across multiple segments and collects the results using a `Collector`.\n  - Creates a weight object for scoring.\n  - Iterates over segments and collects results.\n  - Merges results from all segments.\n  - Returns the aggregated results.\n\nThe `Collector` trait and its methods are crucial for customizing how search results are gathered and processed, allowing for flexible and efficient search operations.\nwhat is a segment?\nIn the context of search engines and indexing systems, a **segment** is a fundamental unit of storage and retrieval. It represents a subset of the entire index, containing a portion of the documents and their associated data. Segments are used to manage and organize the data in a way that allows for efficient searching, updating, and scaling of the index.\n\n### Key Characteristics of Segments\n\n1. **Immutable**: Once a segment is created, it is typically immutable. This means that documents within a segment cannot be changed or deleted. Instead, updates and deletions are handled by creating new segments and marking old documents as deleted.\n\n2. **Self-contained**: Each segment contains all the necessary data to search and retrieve documents within it. This includes:\n   - **Inverted Index**: A data structure that maps terms to the documents that contain them, facilitating fast full-text search.\n   - **Stored Fields**: The actual content of the documents, which can be retrieved when a search result is found.\n   - **Term Frequencies and Positions**: Information about the frequency and positions of terms within documents, used for scoring and relevance ranking.\n\n3. **Independent**: Segments can be searched independently. When a search query is executed, it is run against each segment, and the results are then merged. This allows for parallel processing and efficient use of resources.\n\n4. **Mergeable**: Over time, segments can be merged to optimize performance and reduce the number of segments. This process, known as segment merging, combines smaller segments into larger ones, removing deleted documents and improving search efficiency.\n\n### Why Use Segments?\n\n- **Performance**: By dividing the index into smaller segments, search operations can be parallelized, improving performance and scalability.\n- **Concurrency**: Segments allow for concurrent indexing and searching. New documents can be added to new segments without affecting ongoing search operations.\n- **Efficient Updates**: Since segments are immutable, updates and deletions do not require modifying existing segments. Instead, new segments are created, and old documents are marked as deleted.\n- **Resource Management**: Segments can be loaded and unloaded from memory as needed, allowing for efficient use of system resources.\n\n### Example in the Provided Code\n\nIn the provided Rust code, segments are represented by the `SegmentReader` struct. The `Searcher` struct holds a list of `SegmentReader`s, each corresponding to a segment in the index. Here's how segments are used in the `Searcher`:\n\n- **Segment Readers**: The `Searcher` holds a list of `SegmentReader`s, which are used to read and search the data within each segment.\n  ```rust\n  pub struct Searcher {\n      inner: Arc<SearcherInner>,\n  }\n\n  pub fn segment_readers(&self) -> &[SegmentReader] {\n      &self.inner.segment_readers\n  }\n  ```\n\n- **Searching Segments**: The `Searcher::search` method iterates over the segment readers and performs the search on each segment independently.\n  ```rust\n  pub fn search_with_executor<C: Collector>(\n      &self,\n      query: &dyn Query,\n      collector: &C,\n      executor: &Executor,\n      enabled_scoring: EnableScoring,\n  ) -> crate::Result<C::Fruit> {\n      let weight = query.weight(enabled_scoring)?;\n      let segment_readers = self.segment_readers();\n      let fruits = executor.map(\n          |(segment_ord, segment_reader)| {\n              collector.collect_segment(weight.as_ref(), segment_ord as u32, segment_reader)\n          },\n          segment_readers.iter().enumerate(),\n      )?;\n      collector.merge_fruits(fruits)\n  }\n  ```\n\n### Summary\n\nA **segment** is a self-contained, immutable subset of an index that contains a portion of the documents and their associated data. Segments enable efficient searching, updating, and scaling of the index by allowing for parallel processing, concurrent operations, and resource management. In the provided code, segments are managed by `SegmentReader`s and are used by the `Searcher` to perform search operations across the entire index.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":106}},"image_offsets":[]},{"id":{"replica_id":0,"value":17},"start":11037,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":107}},"image_offsets":[]},{"id":{"replica_id":0,"value":18},"start":15139,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":108}},"image_offsets":[]},{"id":{"replica_id":0,"value":73},"start":15158,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":109}},"image_offsets":[]},{"id":{"replica_id":0,"value":74},"start":19246,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":110}},"image_offsets":[]}],"summary":"Rust Searcher and Collector for Index Querying and Result Aggregation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":10965},"icon":"File","label":"searcher.rs/"}]}