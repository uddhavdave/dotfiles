{"id":"cf3078d5-7a6d-4e7a-af1a-69d00df4a269","zed":"context","version":"0.4.0","text":"\n\n\nCan I use spawn_blocking here intead of spawning a task?\n\nWithout more context, it's hard to give a definitive answer. However, generally speaking, `spawn_blocking` is used when you are running CPU-bound code that could potentially block the thread. `spawn` is typically used for IO-bound tasks and more lightweight, non-blocking tasks.\n\nIf your code involves heavy computation or sync IO operations, it may be beneficial to use `spawn_blocking`. Just remember that it's best to avoid blocking the executor's thread whenever possible, and this is why asynchronous code uses `spawn` most of the time.\n\nIt's also important to note that using `spawn_blocking` can have drawbacks, such as consuming more resources by creating additional threads. It's always advisable to carefully analyze your requirements and your code before deciding which approach to use.\n\n```rs openobserve/src/service/search/grpc/storage.rs:542-574\n// Excerpt from: async fn filter_file_list_by_inverted_index\n    for file in file_list_map.keys() {\n        let full_text_term_clone = full_text_terms.clone();\n        let index_terms_clone = index_terms.clone();\n        let file_name = file.clone();\n        let trace_id_clone = query.trace_id.to_string();\n        let permit = semaphore.clone().acquire_owned().await.unwrap();\n        // Spawn a task for each file, wherein full text search and\n        // secondary index search queries are executed\n        let task = tokio::task::spawn(async move {\n            let res = if use_tantivy {\n                search_tantivy_index(\n                    trace_id_clone.as_str(),\n                    &file_name,\n                    full_text_term_clone,\n                    index_terms_clone,\n                )\n                .await\n            } else {\n                inverted_index_search_in_file(\n                    trace_id_clone.as_str(),\n                    &file_name,\n                    full_text_term_clone,\n                    index_terms_clone,\n                )\n                .await\n            };\n            drop(permit);\n            res\n        });\n\n        tasks.push(task)\n    }\n\n```\ncan you change to spawn_blocking here?\n\nBased on the code you presented, my initial recommendation would be to use `tokio::task::spawn` instead of `tokio::task::spawn_blocking`.\n\nThe search functions you're calling - `search_tantivy_index` and `inverted_index_search_in_file` - are async by nature, which indicates they presumably incorporate IO-bound operations, like database or file access. Blocking function calls - those usually associated with intensive computational operations - and async operations generally differ, so if you were to use `spawn_blocking`, you would effectively block execution.\n\nMoreover, in the Rust context, `spawn_blocking` is customarily utilized within blocking IO-bound or CPU-bound operations that can't become async. By way of illustration, if you're reading from a file synchronously via `std::fs::File::read`, you'd use `spawn_blocking` to prevent blocking the executor.\n\nWithout knowing more about the specifics of your `search_tantivy_index` and `inverted_index_search_in_file` functions, my advice would be guided by the fact that they're async. Consequently, it makes more sense in this context to stick with `tokio::task::spawn`.\n\nIf for some reason these async functions are actually CPU-intensive operations, you should rework them to be synchronous/blocking functions and utilize `spawn_blocking`. But that would be an unusual setup for functions with asynchronous signatures.\n\n```rs openobserve/src/service/search/grpc/storage.rs:668-817\n// Excerpt from: async fn search_tantivy_index\nasync fn search_tantivy_index(\n    trace_id: &str,\n    parquet_file_name: &str,\n    fts_terms: Arc<Vec<String>>,\n    index_terms: Arc<Vec<(String, Vec<String>)>>,\n) -> anyhow::Result<(String, Option<BitVec>)> {\n    let cfg = get_config();\n    let Some(tantivy_index_file_name) =\n        convert_parquet_idx_file_name_to_tantivy_file(parquet_file_name)\n    else {\n        return Err(anyhow::anyhow!(\n            \"[trace_id {trace_id}] search->storage: Unable to find tantivy index files for parquet file {}\",\n            parquet_file_name\n        ));\n    };\n\n    let fetch_start = std::time::Instant::now();\n    let index_file_bytes = fetch_file(trace_id, &tantivy_index_file_name).await?;\n    let elapsed_fetch = fetch_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: fetch_file took {} s, {} ms\",\n        trace_id,\n        elapsed_fetch.as_secs(),\n        elapsed_fetch.as_millis(),\n    );\n\n    let tantivy_searcher_start = std::time::Instant::now();\n    let puffin_dir = PuffinDirReader::from_bytes(Cursor::new(index_file_bytes)).await?;\n    let tantivy_index = tantivy::Index::open(puffin_dir)?;\n    let tantivy_schema = tantivy_index.schema();\n    let tantivy_reader = tantivy_index.reader().unwrap();\n    let tantivy_searcher = tantivy_reader.searcher();\n    let elapsed_tantivy_searcher = tantivy_searcher_start.elapsed();\n    log::info!(\n        \"[trace_id {}] search->storage: tantivy_searcher took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n\n    let mut matched_docs = HashSet::new();\n\n    let mut max_doc_id = 0u32;\n    if !fts_terms.is_empty() {\n        let full_text_field = tantivy_schema.get_field(\"_all\")?;\n        let query_parser = QueryParser::for_index(\n            &tantivy_index,\n            vec![tantivy_schema.get_field(\"_all\").unwrap()],\n        );\n        // TODO(Uddhav): improve this logic\n        // The issue is joining the full text search terms\n        // Ideally there should be multiple queries for each term\n        // and their result should be intersected\n        let query: Box<dyn Query> = match cfg.common.full_text_search_type.as_str() {\n            \"eq\" => query_parser.parse_query(&fts_terms.join(\" \"))?,\n            \"contains\" => Box::new(RegexQuery::from_pattern(\n                &format!(\"*{}*\", &fts_terms.join(\" \")),\n                full_text_field,\n            )?),\n            // Default to prefix search\n            _ => Box::new(PhrasePrefixQuery::new(vec![Term::from_field_text(\n                full_text_field,\n                // we join all the fields that are full text searchable\n                &fts_terms.join(\" \"),\n            )])),\n        };\n\n        let docs = tantivy_searcher\n            .search(&query, &tantivy::collector::DocSetCollector)\n            .unwrap();\n\n        for doc in docs {\n            max_doc_id = cmp::max(doc.doc_id, max_doc_id);\n            matched_docs.insert(doc);\n        }\n    }\n    log::info!(\n        \"[trace_id {}] search->storage: fts_search took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n    for term in index_terms.iter() {\n        let field = tantivy_schema.get_field(&term.0).unwrap();\n\n        let query_parser = QueryParser::for_index(&tantivy_index, vec![field]);\n        // TODO(Uddhav): improve this logic\n        // The issue is joining the secondary index terms\n        // Ideally there should be multiple queries for each term\n        // and their result should be intersected\n        let query: Box<dyn Query> = match cfg.common.full_text_search_type.as_str() {\n            \"eq\" => query_parser.parse_query(&term.1.join(\" \"))?,\n            \"contains\" => Box::new(RegexQuery::from_pattern(\n                &format!(\"*{}*\", &term.1.join(\" \")),\n                field,\n            )?),\n            // Default to prefix search\n            _ => Box::new(PhrasePrefixQuery::new(vec![Term::from_field_text(\n                field,\n                &term.1.join(\" \"),\n            )])),\n        };\n\n        let docs = tantivy_searcher\n            .search(&query, &tantivy::collector::DocSetCollector)\n            .unwrap();\n        for doc in docs {\n            max_doc_id = cmp::max(doc.doc_id, max_doc_id);\n            matched_docs.insert(doc);\n        }\n    }\n\n    log::info!(\n        \"[trace_id {}] search->storage: index_search took {} s, {} ms\",\n        trace_id,\n        elapsed_tantivy_searcher.as_secs(),\n        elapsed_tantivy_searcher.as_millis(),\n    );\n    // return early if no matches in tantivy\n    if matched_docs.is_empty() {\n        return Ok((parquet_file_name.to_string(), None));\n    }\n\n    // Prepare a vec of segment offsets\n    // this is useful when there are more than one segments\n    let seg_metas = tantivy_index\n        .searchable_segment_metas()\n        .context(\"Count segments\")?;\n    let mut res = BitVec::with_capacity(max_doc_id as usize + 1);\n    // rewrite the empty bitvec\n    res.resize((max_doc_id + 1) as usize, false);\n    // Return early if there is only one segment\n    if seg_metas.len() == 1 {\n        for doc in matched_docs {\n            res.set(doc.doc_id as usize, true);\n        }\n\n        log::info!(\n            \"[trace_id {}] search->storage: bitvec took {} s, {} ms\",\n            trace_id,\n            elapsed_tantivy_searcher.as_secs(),\n            elapsed_tantivy_searcher.as_millis(),\n        );\n        return Ok((parquet_file_name.to_string(), Some(res)));\n    } else {\n        return Err(anyhow::anyhow!(\n            \"[trace_id {trace_id}] search->storage: Multiple segments in tantivy index not supported\"\n        ));\n    }\n}\n```\nokay, in this function we are calling tantivy which is cpu intensive, what do you suggest here?\nThe `search_tantivy_index` function is performing heavy work and would benefit from being put into its own blocking task with `spawn_blocking`. However, doing so requires a few changes. Firstly, `spawn_blocking` should not be used in an async context and it's blocking, it will return a future that resolves once the blocking operation finishes. This future can be awaited outside the task, typically in the calling function. \n\nHowever, `tokio::task::spawn_blocking` spaawns a task that is allowed to block, so this function needs to be a sync function not async. \n\nYour code will need be modified in a few ways: \n- Remove all `.await`s \n- The `fetch_file` function should be synchronous. \n- If there are any other async functions being called inside `search_tantivy_index`, they should be made synchronous as well.\n\nBut in the context you are using, there are several async operations like `fetch_file`. If the IO-bound part and CPU-bound part are mixed in a single method, it's not a good idea to use `spawn_blocking` directly. \n\nIf Tantivy search really is a CPU-bound operation and a significant bottleneck, it might be worth refactoring. You might want to refactor the Tantivy search into a separate function and use `spawn_blocking` for this function only after the async task of fetching the file has been done.\nyes, please do that.\nUnfortunately, because \"fetch_file\" function is being called and I'm only seeing an excerpt of your code, it's impossible to fully convert the function to a synchronous one.\n\nNonetheless, below is a simplified blocking implementation of the Tantivy search part assuming the necessary data has already been fetched:\n\n```rs\nfn search_tantivy_index_blocking(\n    trace_id: String,\n    parquet_file_name: String,\n    index_file_bytes: Vec<u8>,\n    fts_terms: Arc<Vec<String>>,\n    index_terms: Arc<Vec<(String, Vec<String>)>>,\n) -> Result<()> {\n    // Assuming that puffin_dir creation was originally async and is now blocking\n    let puffin_dir = PuffinDirReader::from_bytes(Cursor::new(index_file_bytes))?;\n    // Rest of the Tantivy search code...\n}\n\n// And in filter_file_list_by_inverted_index\nfor file in file_list_map.keys() {\n    //... existing setup code ...\n    let index_file_bytes = fetch_file(trace_id_clone.as_str(), &file_name).await?;\n    let task = tokio::task::spawn_blocking(move || {\n        search_tantivy_index_blocking(\n            trace_id_clone,\n            file_name,\n            index_file_bytes,\n            full_text_term_clone,\n            index_terms_clone\n        )\n    });\n\n    tasks.push(task);\n}\n```\n\nPay close attention to removing all async keywords and .await calls and transforming async operations into their synchronous counterparts within the function.\n\nBear in mind however that utilizing `tokio::task::spawn_blocking` for the Tantivy function means the runtime will need to create extra OS threads for these tasks. Should you be dealing with a large number of files, this could potentially reach an upper limit wherein you might encounter performance issues.\n\nYou'll need to perform similar adaptations for referring to async functions present in the `search_tantivy_index` function in order to adjust those functions to a synchronous context. If you could supply the remaining part of your code, especially the async functions `fetch_file` and `convert_parquet_idx_file_name_to_tantivy_file`, it would be easier to provide a more accurate conversion.\nhey can you help\nOf course! I'd be happy to help. Could you please provide more details or clarify what you need help with?\nabove\nI apologize for any confusion, but I need more specific information to provide further assistance. Are you asking for help with converting the `fetch_file` and `convert_parquet_idx_file_name_to_tantivy_file` functions to synchronous versions? Or do you need help with something else related to the `search_tantivy_index` function or the use of `spawn_blocking`? Please provide more details so I can assist you better.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":815}}},{"id":{"replica_id":0,"value":46},"start":61,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":816}}},{"id":{"replica_id":0,"value":47},"start":859,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":817}}},{"id":{"replica_id":0,"value":153},"start":2163,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":818}}},{"id":{"replica_id":0,"value":154},"start":3545,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":819}}},{"id":{"replica_id":0,"value":281},"start":9438,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":820}}},{"id":{"replica_id":0,"value":282},"start":10757,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":821}}},{"id":{"replica_id":0,"value":347},"start":10778,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":822}}},{"id":{"replica_id":0,"value":348},"start":12870,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":823}}},{"id":{"replica_id":0,"value":548},"start":12887,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":824}}},{"id":{"replica_id":0,"value":549},"start":12994,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":825}}},{"id":{"replica_id":0,"value":617},"start":13000,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":826}}},{"id":{"replica_id":0,"value":618},"start":13418,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":827}}}],"summary":"Choosing between spawn_blocking and spawning a task in code","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}