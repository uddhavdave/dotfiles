{"id":"360810c0-83c7-4297-a03f-ab8fe4f9010e","zed":"context","version":"0.4.0","text":"\n\n\n```go Tools/qw_ingestor/quickwit_index_logs.go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tquickwitEndpoint string\n\tindexID          string\n\tapiToken         string\n\tlogFile          string\n\tuniqueTerm       string\n)\n\nfunc createIndexInQuickwit() error {\n\tfmt.Println(\"Creating index in Quickwit...\")\n\n\tyamlData, err := os.ReadFile(\"k8slog-config.yaml\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading YAML file: %w\", err)\n\t}\n\n\turl := fmt.Sprintf(\"%s/api/v1/indexes\", quickwitEndpoint)\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(yamlData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating index request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/yaml\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending index request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\tif !bytes.Contains(body, []byte(\"already exist\")) {\n\t\t\treturn fmt.Errorf(\"failed to create index, received status code: %d\", resp.StatusCode)\n\t\t}\n\t}\n\n\tfmt.Println(\"Index created successfully.\")\n\treturn nil\n}\n\nfunc init() {\n\tflag.StringVar(&quickwitEndpoint, \"quickwitEndpoint\", \"http://localhost:7280\", \"Endpoint for Quickwit\")\n\tflag.StringVar(&indexID, \"indexID\", \"k8slog\", \"Index ID for Quickwit\")\n\tflag.StringVar(&apiToken, \"apiToken\", \"\", \"API token for Quickwit\")\n\tflag.StringVar(&logFile, \"logFile\", \"k8slog_json.json\", \"File containing the data to send\")\n\tflag.Parse()\n\n\terr := createIndexInQuickwit()\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating index: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tuniqueTerm = fmt.Sprintf(\"unique_value_%d\", time.Now().UnixNano())\n}\n\nfunc main() {\n\tdata, err := os.ReadFile(logFile)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading file: %v\\n\", err)\n\t\treturn\n\t}\n\n\tvar logs [][]map[string]interface{}\n\terr = json.Unmarshal(data, &logs)\n\tif err != nil {\n\t\tfmt.Printf(\"Error unmarshalling data: %v\\n\", err)\n\t\treturn\n\t}\n\n\t// Add unique term to the first log entry for identification\n\t// if len(logs) > 0 {\n\t// \tif logField, ok := logs[0][\"message\"].(string); ok {\n\t// \t\tlogs[0][\"message\"] = logField + \" \" + uniqueTerm\n\t// \t}\n\t// }\n\ttotalIterations := 0\n\ttotalMaxIterations := 150000\n\tmaxThreads := 8\n\tfor totalIterations < totalMaxIterations {\n\t\tfmt.Println()\n\t\tbatchSize := 10000\n\t\tfmt.Printf(\"Running batch with size: %d\\n\", batchSize)\n\n\t\tvar wg sync.WaitGroup\n\t\tsem := make(chan struct{}, maxThreads)\n\n\t\tfor i := 0; i < batchSize; i++ {\n\t\t\tsem <- struct{}{}\n\t\t\twg.Add(1)\n\n\t\t\tgo func() {\n\t\t\t\terr = sendLogsToQuickwit(logs)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"Failed to send logs at iteration %d: %v\\n\", i, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t<-sem\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\n\t\ttotalIterations += batchSize\n\n\t\twg.Wait()\n\n\t\tfmt.Println() // Add new line after completing a batch\n\n\t\ttime.Sleep(20 * time.Second)\n\n\t\tsearchResults, err := searchLogsInQuickwit(uniqueTerm)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error searching logs: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\"Total Iterations: %d\\n\", totalIterations)\n\t\tfmt.Printf(\"Search Results for unique term '%s': %v\\n\", uniqueTerm, searchResults)\n\t}\n}\n\nfunc sendLogsToQuickwit(logs [][]map[string]interface{}) error {\n\tfmt.Println(\"Sending logs to Quickwit...\")\n\n\tdata, err := json.Marshal(logs)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshalling logs: %w\", err)\n\t}\n\n\turl := fmt.Sprintf(\"%s/api/v1/%s/ingest?commit=force\", quickwitEndpoint, indexID)\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending logs: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to send logs, received status code: %d\", resp.StatusCode)\n\t}\n\n\tfmt.Println(\"Logs sent successfully.\")\n\treturn nil\n}\n\nfunc searchLogsInQuickwit(term string) ([]map[string]interface{}, error) {\n\tfmt.Printf(\"Searching logs in Quickwit for term '%s'...\\n\", term)\n\n\tquery := map[string]interface{}{\n\t\t\"query\": fmt.Sprintf(\"message:'%s'\", term),\n\t\t\"size\":  10,\n\t}\n\n\tdata, err := json.Marshal(query)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling search query: %w\", err)\n\t}\n\n\turl := fmt.Sprintf(\"%s/api/v1/%s/search\", quickwitEndpoint, indexID)\n\treq, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(data))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error creating search request: %w\", err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error searching logs: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar results []map[string]interface{}\n\terr = json.NewDecoder(resp.Body).Decode(&results)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decoding search results: %w\", err)\n\t}\n\n\treturn results, nil\n}\n```\n\nError unmarshalling data: invalid character '{' after top-level value\nThe error message you're encountering, `Error unmarshalling data: invalid character '{' after top-level value`, suggests that the JSON data you're trying to unmarshal is not formatted correctly for the expected structure. In your code, you are attempting to unmarshal the data into a `[][]map[string]interface{}` structure, which indicates that you expect a JSON array of arrays, where each inner array contains a map (object in JSON terms) with string keys and arbitrary values.\n\nTo resolve this issue, you need to ensure the JSON data matches the expected structure. Here's what you can check and correct:\n\n1. **Check the JSON Structure**: Make sure the JSON file `k8slog_json.json` is formatted correctly. The format should be similar to:\n    ```json\n    [\n      [\n        {\"key1\": \"value1\", \"key2\": \"value2\"},\n        {\"key1\": \"value3\", \"key2\": \"value4\"}\n      ],\n      [\n        {\"key1\": \"value5\", \"key2\": \"value6\"}\n      ]\n    ]\n    ```\n\n2. **Adjust Your Code If Needed**: If your data doesn't fit this structure, you may need to adjust the type you're unmarshalling to. For example, if your JSON data is not nested like an array of arrays but instead just an array of objects, you should unmarshal into a simpler `[]map[string]interface{}` structure. Adjust your unmarshalling logic to the correct data structure. Here is an example modification:\n\n    ```go\n    var logs []map[string]interface{}\n    err = json.Unmarshal(data, &logs)\n    if err != nil {\n        fmt.Printf(\"Error unmarshalling data: %v\\n\", err)\n        return\n    }\n    ```\n\n3. **Validate the JSON**: Use a JSON validator tool or a JSON linting service to check if your JSON file has any syntax errors that might cause issues when parsing it in Go.\n\nIf you continue facing issues, double-check the contents of the `k8slog_json.json` file to ensure it is a valid JSON file and matches the intended structure.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":23}}},{"id":{"replica_id":0,"value":8},"start":5244,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":24}}},{"id":{"replica_id":0,"value":9},"start":7126,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":25}}}],"summary":"Debugging JSON Unmarshal Error in Go","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":5173},"icon":"File","label":"Tools/qw_ingestor/quickwit_index_logs.go","metadata":{"path":"Tools/qw_ingestor/quickwit_index_logs.go"}}]}